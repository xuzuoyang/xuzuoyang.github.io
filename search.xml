<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ssh]]></title>
    <url>%2F2018%2F06%2F03%2Fssh%2F</url>
    <content type="text"><![CDATA[references http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/ 基本概念 ssh是一种协议，用来安全登录远程服务器 第一次登录时，需要同意添加远程主机的公钥，然后本机会利用此公钥加密登录密码，从而实现安全登录 中间人攻击会假扮远程主机，用伪造的公钥获取登录密码，所以在第一次同意添加远程服务器时需要谨慎 添加后的公钥会被保存在$HOME/.ssh/known_hosts文件中，另外系统也会有相应的文件，保存在/etc/ssh/ssh_known_hosts中 ssh提供两种登录方式 密码登录 公钥登录：需要添加本机的公钥到远程主机 基本用法 ssh-keygen用来生成本机的公钥和私钥，分别保存在$HOME/.ssh/下面的id_rsa.pub和id_rsa ssh-copy-id user@server用来把本机的公钥传送到远程服务器，之后就可以实现免密登录了，注意可能需要重启server的ssh服务，service ssh restart 更多用法 本地生成多个公钥 通过ssh config配置登录的参数]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux用户]]></title>
    <url>%2F2018%2F06%2F03%2Flinux%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[reference https://unix.stackexchange.com/questions/121071/what-does-adduser-do-that-useradd-doesnt ​ 基本概念 id命令可以用来查看用户的基本信息，如下 uid=1000(duoduo) gid=1000(duoduo) groups=1000(duoduo),27(sudo) 最后的groups表示此用户所在的组，sudo组说明可以行使sudo超级用户权限 用户的信息存储在一系列的文本文件中 /etc/passwd 用户名、uid/gid、家目录、登录shell等 /etc/group 用户组信息 /etc/shadow 用户密码信息 /etc/sudoers sudo用户信息，默认只有root 现在的linux新建用户之后会默认创建一个同名的用户组来放置新用户 su可以用来切换到其他用户，-l表示新开shell也可以只写-，所以su - 默认打开root用户的shell，不过需要root密码。因为用户不应该互相知道对方的密码，所以最好不要用su而是用sudo代替 sudo可以用来赋予要执行的命令超级用户的权限，前提是当前用户在sudo组，也就是sudoer。sudo需要输入的是当前用户的密码而不是root的密码，这样增加了超级用户账户的安全性。 创建新用户 useradd是底层的创建用户命令，需要加其他的参数来帮助创建家目录、指定登录shell等操作 useradd -r -m -s /bin/bash duoduo # -r建立系统账号，-m创建登录目录，-s指定登录shell 推荐使用adduser来新建用户，adduser duoduo会执行以下操作 创建名为duoduo的用户 创建家目录，默认/home/duoduo并复制 /etc/skel的文件到下面 创建一个名为duoduo的用户组并把新用户放进去 提示输入新用户密码 提示输入新用户其他信息 另外adduser可以用来添加一个用户到其他的group，adduser username newgroup adduser duoduo sudo 添加用户duoduo成为sudoer usermod命令也可以用来添加用户到sudo组，usermod -aG newgroup username usermod -aG sudo duoduo # -a表示append到新的group]]></content>
  </entry>
  <entry>
    <title><![CDATA[http安全]]></title>
    <url>%2F2018%2F04%2F22%2Fhttp%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[参考： HTTP权威指南 https://segmentfault.com/a/1190000012466003 https://www.zhihu.com/question/33645891 https://segmentfault.com/a/1190000010540911 1. authentication basic auth digest auth oauth(open auth) 2. 加密 对称：发送方和每个收信方都要约定一个相同的key用来加密，这样一来会有很多key要维护，其次key的共享过程中很可能暴露，安全隐患较大 非对称：如RSA算法，每个发送/接收方都维护一个public key和private key，公共密钥用来给别人加密要传送给自己的内容，而自己可以通过private key来解密报文，而且所有人都可以用这一个公共密钥来加密，解决了对称加密技术的成对密钥的N^2扩展问题 混合加密：公开密钥的加密算法计算可能会很慢，所以常见的做法是混合对称和非对称加密方法，如先通过非对称方式建立安全通道，然后发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据加密 3. 数字签名/证书 数字签名：针对发送方可能会被假冒的情况，数字签名即发送方利用自己的私钥制作的特殊校验码，加在报文之后，这样的好处一是接收方可以通过公钥解密签名确认发送方身份，第二是防止报文被篡改，因为攻击者无法制作出私钥才能产生的校验码，所以报文内容被修改的话校验和会不再匹配 数字证书：证书是第三方的签发机构，上面会有web站点（可以理解为发送方）的名称、主机名和公钥，还有签名机构的名称和签名，由于很多权威机构的证书会被预装到浏览器中，所以浏览器其实相当于已经知道颁发证书机构的公钥，通过证实该机构的签名即可认证web站点是安全的 感觉签名和证书可以存在一种嵌套的关系，证书就是新的签名为旧的签名来担保，所以可以存在更多的签名来层层担保，直到最后的根证书。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>auth</tag>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http基础]]></title>
    <url>%2F2018%2F04%2F22%2Fhttp%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[shell]]></title>
    <url>%2F2018%2F04%2F10%2Fshell%2F</url>
    <content type="text"><![CDATA[shell &amp; 终端 &amp; 终端模拟器TBC shell命令 文件目录 cp/mv/mkdir/rm/ln/ls ls ls -d */ ls -p | grep -v / 需要梳理一下/bin /usr/bin /usr/local/bin等关系 权限操作 用户 /etc/passwd, /etc/group, /etc/shadow su/sudo adduser/useradd/groupadd 文件 属性 文件类型： d/-/l/b/c 2~9: owner(rwx), group(rwx), others(rwx) 目录的rwx r: ls 前提要有x w: 新建或删除文件，前提要有x x: cd chmod 八进制表示法, octal: 755/422 符号表示法: 多种设定可用逗号分隔，u+x,go=rw 更改谁: u/g/o/a 操作: +/-/= 权限: rwx chown/chgrp umask 命令之上 type/which/man/info/apropos/alias 重定向 管道 expansion &amp; quoting 文件/文本 输出 cat head/tail less Filter sort/cut/uniq/wc 搜索 find &amp; grep &amp; xargs tr awk sed find &amp; grep &amp; xargs find -name: find . -name “*.py”得加双引号，自带递归效果 -i Ignore case -mindepth/maxdepth 搜索深度 -exec: find . -iname “*.py” -exec md5 {} \; 待续 -not Inverting match -perm octal/symbolic i.e. g=r/-g=r/644 -empty -type d/f/s(socket) -size +100M/-100M/100M 单位可以是k/M/G -newer 时间 查找隐藏文件或目录 find -type d/f -name “.*” 查找最大或最小的N个文件 待续 grep grep somestring/‘regex’/“regex” [file1, file2…]/FILE_PATTERN -r 可指定目录搜索 -i Case Insensitive -w Search for full words -A, B, C Display lines after/before/around match -v Invert match -e Pattern -c Count matched lines -l Display matched file names -n Display matched line number -o show only matched string 这个在数匹配数的时候很有用，因为其他情况下只会列出匹配的行数而不是个数 grep也接受标准输入，所以可以这么用grep foo - / echo longstrinput | grep somestr OR: -e “PATTERN1” -e “PATTERN2”或者-E “P1 | P2” E和e 是不一样的，-e指代pattern，E表示extended regexp AND: -e “P1.*P2” 或者用管道 NOT: -v或者管道 –exclude/–exclude-dir/–include “PATTERN” 正则表达式 ^PATTERN / PATTERN$: start/end of the line . single charactor */+/?: 0 or more/1 or more/0 or 1注意+和？前面要加反斜杠escape [123]/[1-9] 在[]里加^表示反 |表示OR，要escape {m, n}/{m}/{m,} 出现次数，包含边界，要escape IP address “\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)” 待续 xargs ls somefiles | grep somestr和ls somefiles | xargs grep somestr结果不同，因为前者是针对列出的文件名结果进行搜索，而后者才是对这些文件的内容搜索，原因就是xargs可以用来把标准输入转化成参数。前者因为grep也可以接受标准输入所以搜索的对象是文件名，后者则是把这些文件转化成grep的文件参数 find . -name ‘foldername’ | xargs cd 是无法进入文件夹的，因为cd是shell内建的函数，xargs执行的是文件命令，即/usr/bin/cd folder是无法进入文件夹的]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pdb-in-python]]></title>
    <url>%2F2018%2F03%2F01%2Fpdb-in-python%2F</url>
    <content type="text"><![CDATA[Python Debugger 使用方法 python -m pdb script.py 从头开始调试 代码加入import pdb;pdb.set_trace() 从指定代码处调试 功能介绍 单步调试 设置断点 查看栈片段 动态改变变量值 调试过程中查看代码 快捷键 调试过程 step/next/until/return 单步/跳过函数内部/跳过循环/到返回值 p/pp 打印 l/l no1, no2/ll 打印代码片段/打印行间片段/打印函数片段 continue/quit 继续执行/退出 打印栈 where 打印stack trace up/down 返回上级栈片段/进入新一级栈片段 断点 break/break lineno 显示断点/设置断点 command 给断点设置执行指令 jump lineno 可以向前后向后跳 其他 args 显示当前作用域的参数 help/h [cmd] 显示帮助 缺点 多线程调试 远程调试 参考 https://pymotw.com/2/pdb/ https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/ IPDB 待补充 ExceptionHookPUDBIDE]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>debug</tag>
        <tag>pdb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的click工具库]]></title>
    <url>%2F2018%2F01%2F22%2Fpython%E7%9A%84click%E5%B7%A5%E5%85%B7%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Setup click是一个非常好用的用来开发CLI程序的python第三方库，相对于argparse更加简单易用 click中用了装饰器的形式来定义命令和参数，如下所示，即可完成一个命令行 123456789import click@click.command()@click.argument('name')@click.option('--times', type=int, default=1, help='How many times to greet')def greet(name, times): if times: for i in range(times): print('Greetings to %s' % name) 最后一步只需要配置好setup.py即可完成简易命令行的开发，内容如下 12345678910111213141516from setuptools import setup, find_packages VERSION = '0.1'setup( name='myclick', version=VERSION, description='An example of click', packages=find_packages(), entry_points=&#123; 'console_scripts': [ 'greet=myclick:greet', ] &#125;, install_requires=['click'],) ​ parameter parameter分成arguments和options两种 arguments: can accept arbitrary number of args options: 自动prompting | act as flags | from env parameter types str/int/float/bool click.STRING/INT/FLOAT/BOOL/UUID click.File/Path click.Choice/IntRange parameter name -f, –foo-bar, dest f &lt; foo_bar &lt; dest options nargs type (unicode, int) 可以是multi multiple -m foo -m bar is_flag ‘–shout/–no-shout’, default=False prompt True/‘Your name please’ hide_input @click.password_option ??? default lambda: os.environ.get(‘USER’, ‘’) is_eager/exposed_value/confirmation_option callback=func, func(ctx, params, value) envvar=’USERNAME’, could be multiple ###arguments nargs=-1, unlimited tbc help command和option有help， argument没有help tbc group tbc]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的命名空间和作用域]]></title>
    <url>%2F2018%2F01%2F22%2Fpython%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Environment based on Python3.6 概念 简单的理解，命名空间就是object和name的映射集合，python的实现为一个dict，而作用域也就相当于命名空间生效的文本区域，如官方文档里所说，Scopes are determined textually. globals和locals这两个builtin function可以用来获取全局作用域和当前本地作用域的变量字典，如果修改的话，那么lookup的结果也会改变 python中的作用域基本分四种，LGBT，错了…晕，是LEGB，Local &amp; Enclosing &amp; Global &amp; Builtin，即最内部（可能是函数里的函数）&amp; 次外部 &amp; 全局 &amp; 最外部也就是包含了builtin functions的scope，查找变量的话从里向外查找 ### 关键字 有local, nonlocal和global三个关键字，可以用来指定变量的作用域。顾名思义不解释了。 看官方文档发现了个小坑，nonlocal和global，前者如果指定一个没有定义的变量会报错，后者则不会，但是global不能在同一个作用域先被定义，然后用global指定。 Names listed in a global statement must not be used in the same code block textually preceding that global statement. Names listed in a global statement must not be defined as formal parameters or in a for loop control target, class definition, function definition, importstatement, or variable annotation. Names listed in a nonlocal statement, unlike those listed in a global statement, must refer to pre-existing bindings in an enclosing scope (the scope in which a new binding should be created cannot be determined unambiguously). Names listed in a nonlocal statement must not collide with pre-existing bindings in the local scope. 然后放一个官方示例提醒自己，看懂了基本就想起来了 12345678910111213141516171819202122def scope_test(): def do_local(): spam = "local spam" def do_nonlocal(): nonlocal spam spam = "nonlocal spam" def do_global(): global spam spam = "global spam" spam = "test spam" do_local() print("After local assignment:", spam) do_nonlocal() print("After nonlocal assignment:", spam) do_global() print("After global assignment:", spam)scope_test()print("In global scope:", spam) 1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 内置函数 globals(). Return a dictionary representing the current global symbol table. 把当前模块范围定义的变量字典。可以在获取当前模块定义的类或函数时自省，非常方便，另外可以直接修改这个字典来改变模块内的变量的定义。 1234567def myfunc(): pass # 此时globals()['myfunc']的结果如下&#123;'myfunc': &lt;function __main__.myfunc&gt;&#125;globals()['myfunc'] = 0# 此时globals()['myfunc']结果为0 locals(). 获取当前局部作用域的变量字典。注意修改这个字典可能不会影响变量的定义，这点与globals()不同。 1234567891011121314def myfunc(): a = 11 print(locals()) # 此时执行myfunc的结果如下&#123;'a': 11&#125;def myfunc(): a = 11 locals()['a'] = 22 print(locals()) # 此时执行myfunc的结果不会改变&#123;'a': 11&#125; vars(). Return the __dict__ attribute for a module, class, instance, or any other object with a __dict__ attribute.基本和locals()的用法一样，注意，locals dict是用来读取而不应该修改的。 Objects such as modules and instances have an updateable __dict__ attribute; however, other objects may have write restrictions on their __dict__ attributes (for example, classes use a types.MappingProxyType to prevent direct dictionary updates). Without an argument, vars() acts like locals(). Note, the locals dictionary is only useful for reads since updates to the locals dictionary are ignored.]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>namespace</tag>
        <tag>scope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json-in-python]]></title>
    <url>%2F2018%2F01%2F06%2Fjson-in-python%2F</url>
    <content type="text"><![CDATA[12345678910import jsonwith open('filepath', 'w') as f: for item in data: json.dump(item, f) f.write('\n') with open('filepath') as f: for item in map(json.loads, f): print(item)]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deepin折腾总结]]></title>
    <url>%2F2018%2F01%2F06%2Fdeepin%E6%8A%98%E8%85%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[家里的台式机一直装着双系统，可惜ubuntu16.04折腾了几个来回也没获得满意的效果，于是后来就变成每次开机都要点引导项进windows，偶尔进ubuntu看一眼也会被必中的无名bug和难看的界面搞到无奈，毕竟即使把vim&amp;tmux&amp;zsh&amp;guake搞上也无法跟平常用的mac比，不过大概主要还是因为linux用的烂吧… 后来有了契机好好学了学vim&amp;tmux的配置和使用，又忽然跟同事聊到linux的dist，于是想到，为什么不尝试下深度呢，毕竟口碑还是不错的，而且ubuntu已经彻底不想要了。嗯…历经一个周末加几个晚上的折腾，总算把系统和开(娱)发(乐)工具配得差不多了，确实爽的飞起，基本已经不开windows了，当然是如果不打游戏的话。 另外总算趁着元旦把ikbc的蓝牙键盘剁手了，降了一百果然感觉好像白送了一样呢= =。不过在深度上配蓝牙的时候大脑短路了没看到蓝牙管理器，其实安装了blueman之后在下方的系统托盘里就能看见了。不过蓝牙的８７键还是放在单位吧，把有线的１０８拿回来就好，哈哈，此时打字已经爽到爆炸。 嗯…不扯淡了，下面简单记录一下深度的安装（主要是显卡驱动，我是Ｎ卡）AND 深度的系统的一些使用特点 AND 就是自己开发环境的一些记录了（主要是安装的坑…每次都是现查现解决真的太没效率了，我要把犯过的傻都写下来…嗯），OK，开始 Install Deepin 首先就是把之前的ubuntu卸载了，清理一下启动项。其实就是检查一下有没有要备份的数据，然后win10用EasyUEFI删一下linux的启动项，然后把硬盘格式化一下就好了 安装的话就是Ｕ盘安装，对了，下载的deepin15.5的版本，记得下了好久，直接就把电脑开了一晚上…然后制作工具的话深度官网提供了一个，直接用就好，然后安装就好了，轻松加愉快 记得安装的时候好像有选是简单还是专家，其实就是分区的选项，嫌麻烦直接简单就可以，不过安完之后进去直接我就黑屏了…Ｎ卡真是坑，不过这不是得玩游戏么… 黑屏的问题直接搜nomodeset就好了，不过进去之后分辨率弱到爆，还只有一种，差点我就弃坑了…上官网搜了搜发现是显卡驱动的事儿。安装的细节都说得很清楚，双显卡貌似比较折腾，而且很多都是针对笔记本，这点要注意。我是台式机，双显卡，不过我不care显卡的切换，直接用Ｎ卡就很合适，所以我只去装了Ｎ卡的闭源驱动，也就是NVIDIA自己出的版本，follow教程就好。但是我发现我的问题是开机还是得用nomodeset进入，会报_DSM什么之类的错误，懒得再折腾了，以后再说 对了，深度商店除了显卡驱动管理器，所以安装的话不用敲命令，可以直接在上面选，不过这个管理器也就是起一个帮助安装的功能而已… 装完驱动之后分辨率就好多了，然后可以发现深度的UI还是很nice的，给了我继续踩坑的信心，颜值即正义嘛= = Explore Deepin 首先看到了深度自带的一堆软件，感觉还是非常好的，Chrome &amp; Thunderbird &amp; 福昕阅读器 &amp; Chm阅读器等等，另外就是深度影音很棒，这样我基本就可以不用切windows了，作为把大部分时间花在视频娱乐的人…另外深度商店里东西也很多，像必备的SS（真是惊到了），网易云，搜狗输入法等等，节省了超多的额外去折腾安装这些东西的时间 对于搜狗输入法，一开始系统语言选english的是不会预装的，所以这时候你应该切换到中文，然后安装，然后再改回英文，嗯…应该是这个顺序 其他的在桌面右侧提供的设置里面都非常全，包括还有很多快捷键都还没来得及好好看，不过肯定很方便就是了 Dev Tools 首先就是终端了，deepin提供了自己的终端，一开始觉得不好用，颜色什么的都不能配置，不过后来发现还不错，它是内置了很多主题可以选择，像主流的solarized都有，不过有一点比较坑，就是要注意它的快捷键，我就手贱把复制设置成ctrl-c，然后在配vim的时候冲突了，纠结了一晚上…另外还有个很棒的雷神模式，alt+f2，这样也不用装guake了，非常棒 先要做的是把zsh装上，然后oh my zsh，别忘了把shell从bash改成zsh，chsh -s /bin/zsh，大概这样就好。然后就是主题了，对于肤浅的我来说是个非常耗时的工作，主要就是选zsh的主题然后配合deepin终端的颜色主题，经过几十番折腾选了ys + elementary，感觉还是不错的，以后的话可能考虑自己再配一下ys，默认就很好了已经 然后就是vim &amp; tmux了，当然正在尝试nvim，所以也都安装配置了，vim的快捷键刚才说了不要跟终端的快捷键冲突，否则想不起来的话真的会纠结很久… 另外因为在用hexo做博客所以还装了typora做markdown的编辑器，typora很不错，三平台都支持，点赞。在装hexo的时候碰到一点坑，npm可以直接apt-get装，不过用npm装hexo的时候出现了proxy的错误，查了查发现是我用了ss但是没给npm配置，所以用npm config set proxy url(http://blabla)就可以了，确认一下系统代理的协议就好。 对了hexo的文件夹在不同机器上同步备份确实是个小问题，知乎上好像有各种解决办法，github再弄个repo啊，自己写个小工具啊，dropbox啊，我表示我直接u盘拷过来了…很快嘛明明，不过最好再传到网盘就是了 对了还有，python的一套东西，差点忘了…深度自带了python2 &amp; 3，不过是3.5，倒也还好，apt-get 装一下python3-pip就好，然后别忘了再.zshrc里面加PATH，好像是可以用python -m site查看路径，要不pip或者pip3装的命令用不了的同志们，为此又浪费了快半个小时…另外pip安装的话最好是加–user，不要用sudo，详细可见pipenv作者的解释，有理有据= =。装好了可以在~/.local/bin里面找找，安利一下pipenv，你值得拥有。 别的就是用什么装什么了，git，docker，一些小命令tree啊什么的…嗯，暂时就想到这么多了，OK，打完收工 后记 这里记一下一些小细节，做备忘吧。这两天纠结了下改键的事儿，一开始用xmodmap，写了命令到~/.Xmodmap文件里，结果出了各种bug，配合tmux也出问题。google了下发现有个好使的setxkbmap，一条命令搞定，setxkbmap -option ctrl:swapcaps，哈哈，好用，妈妈再也不用担心咯。p.s. 看了下archwiki，应该是在X-server处覆盖了布局，还说xmodmap改了内部映射表，不适合complex tasks，果然啊。。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[argparse-in-python]]></title>
    <url>%2F2017%2F12%2F21%2Fargparse-in-python%2F</url>
    <content type="text"><![CDATA[argparseargparse模块是python的内置模块，用来写一些CLI的工具，替代了之前的optparse ArgumentParser是argparse的解析器类，用来新建一个parser对象，命令的添加都要从这个对象开始 1234567891011121314151617import argparseparser = argparse.ArgumentParser( description='this is an example parser')parser.add_argument('-a', action='store', default=1, type=int)parser.add_argument('-b', action='store_true', dest='flag')parser.add_argument('-c', action='append', default=[])print( parser.parse_args( ['-a', 3, '-b', '-c', 'one', '-c', 'two'] ))# result# Namespace(a=3, flag=True, c=['one', 'two']) add_argument主要有action, default, dest, type几个参数，dest表示传入的值将保存在dest对应的变量名中 parse_args返回的是一个Namespace对象，可以直接用attr的形式获取，如result.flag 没有传入的参数默认都为None，除非default有设定 parse_args 默认是从sys.argv[1:]获取参数 action的几种选择 store是默认选择，表示直接保存值，当然可能会做类型转化 store_true / store_false 表示存入布尔值，不传的话前者默认False后者True store_const 表示存入一个预设好的常量值，用const表示，用于存布尔值之外的flag append / append_const 表示把值存入一个列表中，后者则存预设好的值 version 会打印版本的信息然后退出 123456parser.add_argument('-A', action='append_const', dest='const_list', const='A_CONST', default=[])parser.add_argument('-B', action='append_const', dest='const_list', const='B_CONST', default=[])print(parser.parse_args(['-A', '-B']))# result# Namespace(const_list=['A_CONST', 'B_CONST']) 1234parser.add_argument('--version', action='version', version='%(prog)s 1.0')# resultargparse_test.py 1.0 共享Parser123parser = argparse.ArgumentParser( parents=[another_module.parser]) 注意把parent parser的add_help设置成False比较好 Group argparse默认使用两个group，一个用于positional arguments，另一个optional arguments 12parser.add_argument('--optional', action='store_true')parser.add_argument('postional', action='store') 打印的结果 123456positional arguments: positionaloptional arguments: -h, --help show this help message and exit --optional 使用group可以让命令更有逻辑，在help中显示的结果会把同组的命令放在一起，更加合理 12345678import argparseparser = argparse.ArgumentParser(add_help=False)group = parser.add_argument_group('authentication')group.add_argument('--user', action="store")group.add_argument('--password', action="store") 打印结果 123456optional arguments: -h, --help show this help message and exitauthentication: --user USER --password PASSWORD 使用mutually exclusive options可以得到两个互斥的argument，不能同时使用 123456789import argparseparser = argparse.ArgumentParser()group = parser.add_mutually_exclusive_group()group.add_argument('-a', action='store_true')group.add_argument('-b', action='store_true')print(parser.parse_args()) ​ 嵌套parserNesting Parser的好处就是可以创建多个并列的命令或子命令参数，比如写一个文件的CLI，提供list / create / delete三种命令，就适合使用subparser 12345678910111213import argparseparser = argparse.ArgumentParser()subparsers = parser.add_subparsers(help='commands')list_parser = subparsers.add_parser('list')list_parser.add_argument('dirname')create_parser = subparsers.add_parser('create')create_parser.add_argument('dirname')delete_parser = subparsers.add_parser('delete')delete_parser.add_argument('dirname') 需要让不同的subparser执行不同方法的话 123456def f_list: passlist_parser.set_defaults(func=f_list)args = parser.parse_args('list .'.split())args.func(args) 需要知道是哪个parser起作用的话 1234subparsers = parser.add_subparsers(dest='subparser_name')subparser2 = subparsers.add_parser('2')subparser2.add_argument('y')parser.parse_args(['2', 'frobble']) 更多的add_argument的参数 nargs可以指定传入参数值的个数 N表示具体的个数 ？表示0个或者1个 * 表示0个或者多个 + 表示1个或者多个 type表示参数值的类型，可以是int, float甚至是open，用来打开一个文件 metavar用来在help打印的结果中refer一个参数，否则默认的话positonal argument使用dest，optional argument使用大写dest required可以强制某个参数为必须参数，在argparse中，形如-f或者—bar的参数默认为optional的，但是如果把required设置成True的话不提供参数值就会报错，当然这么用并没有什么意义就是了]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[install-in-python]]></title>
    <url>%2F2017%2F12%2F17%2Finstall-in-python%2F</url>
    <content type="text"><![CDATA[Terms&amp;Howtos about installation in python3.6, for clear the mess in mind Reference: https://packaging.python.org/tutorials/distributing-packages/#packaging-your-project https://blog.zengrong.net/post/2169.html http://pyzh.readthedocs.io/en/latest/python-setup-dot-py-vs-requirements-dot-txt.html Distribution Package from glossary A versioned archive file that contains Python packages, modules, and other resource files that are used to distribute a Release. The archive file is what an end-user will download from the internet and install. 说白了就是python包，比如一个requests的压缩文件，打开之后里面就是requests的源码文件 Built Distribution &amp; Binary Distribution 应该叫做构建版本吧，提供files and metadata，比如wheel，但是sdist(Source Distribution)不算，因为它需要build之后才生成一个Built Distribution Binary Distribution属于特殊的Built Distribution，即包含了编译好的文件 Egg &amp; Wheel Egg是setuptools引进的一种Built Distribution的格式，和Wheel一样，后者pip提供支持，并用来替代前者 总结就是sdist是一种distribution格式，Egg和Wheel是Built Distribution的格式 Source Distribution &amp; Wheels from tutorials pip can install from either Source Distributions (sdist) or Wheels, but if both are present on PyPI, pip will prefer a compatible wheel. Wheels are a pre-built distribution format that provides faster installation compared to Source Distributions (sdist), especially when a project contains compiled extensions. If pip does not find a wheel to install, it will locally build a wheel and cache it for future installs, instead of rebuilding the source distribution in the future. pip pip是最常用的安装工具，注意版本的区别，要装到python3上面 —user用来安装到当前用户下的目录，而不是全局 —upgrade用于升级已经安装的python包 —index-url / —extra-index-url，从其他源安装或者除了PyPI加上额外的安装源库，可以是豆瓣或者阿里等等 另外还有—process-dependency-links，—extra-actions等参数 pip show可以用来查看安装的包的信息，还有安装位置，非常好用 pip check可以检查requirements是否存在互斥的情况 pip10使用pip.req使用会报no module的错误，暂时可用pip._internal.req代替，或者downgrade到pip9, pip install pip==9.0.1 pip -e/–editable 适合安装从url获取或者本地的开发代码，实际上pip包装了setuptools develop的功能，会把相关的代码维护在一个src文件夹内，生成一个xxx.egg-link文件指向这个src文件夹（本地的话src就是开发目录），这样修改其中的代码就能够直接生效，而不需要重新build。除了xxx.egg-link可能还会生成xxx.pth文件，来把相关的dependency放进sys.path使其生效。还有一个坑就是如果一个工程嵌套着许多小工程的话那么用editable模式安装最外层的setup.py可能无法起到预想的效果，这个时候就需要在小工程里面单独-e安装 乱斗解析 乱斗名词：distutils, setuptools, distribute, egg&amp;wheel, setup.py&amp;requirments.txt, pip&amp;easy_install 需求：安装/构建/分发 distutils是python standard tool for packaging，标准库的一部分，用它可以进行python模块的安装和发布，setup.py就是利用distutils的功能写成，也就是setup脚本 setuptools是distutils的增强集合，包含了easy_install这个安装工具，distribute就是它的一个分支，已经回归，并且被弃用了 setuptools setuptools (which includes easy_install) is a collection of enhancements to the Python distutils that allow you to more easily build and distribute Python distributions, especially ones that have dependencies on other packages. distribute was a fork of setuptools that was merged back into setuptools (in v0.7), thereby making setuptools the primary choice for Python packaging. 使用setuptools可以自动下载/构建/安装/管理python模块 Egg格式是setuptools引入的一种文件格式，使用.egg扩展名，Eggs are to Python as Jars to Java 哈哈 Pip被用作是easy_install的替代品，希望不在使用Egg格式，而是源码发行版，即python setup.py sdist Wheel本质是一个zip包格式，使用.whl扩展名，它的出现是为了替代Eggs，前文已经解释，它是bdist而不是sdist Setup.py和requirements.txt都支持描述依赖的包名称和版本，不过也可以共存，可以分别提供抽象依赖和具体依赖，详见Reference3 噢对了，twine是用来和PyPI交互的工具 Twine is a utility for interacting with PyPI, that offers a secure replacement for setup.py upload.]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>distribution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[list/set/dict-in-python]]></title>
    <url>%2F2017%2F12%2F16%2Flist-set-dict-in-python%2F</url>
    <content type="text"><![CDATA[Environment based on Python3.6 list extend方法，接收iterable类型，如list/tuple/set/dict等 remove用于删除某个元素，如果元素不存在会报错，在迭代过程remove是大忌 clear方法用于清空，也可以用del加切片 index方法可接受x, start, end三个参数 count方法很实用 排序的两个方法，reverse和sort, sort可接受key和reverse两个参数 123456789&gt;&gt;&gt; a = list(range(5))&gt;&gt;&gt; a[0, 1, 2, 3, 4]&gt;&gt;&gt; a.sort(key=lambda x: abs(x-2))&gt;&gt;&gt; a[2, 1, 3, 0, 4]&gt;&gt;&gt; a.sort(key=lambda x: abs(x-2), reverse=True)&gt;&gt;&gt; a[0, 4, 1, 3, 2] copy方法，属于浅拷贝，嵌套list还是需要deep_copy 用作栈，append和pop搭配即可 用作队列，insert成本较高，不建议；可用deque，配合append和popleft方法 ​ Tuple Sequence types包含了list, tuple和range 单个元素的tuple声明需要逗号，如a = ‘hello’,即可 tuple packing&amp;unpacking, 不用加圆括号 set 用大括号来声明，但是不能为空，为空的话声明的将是dict set operations： -, |, &amp;, ^ 123456789101112&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; a # unique letters in a&#123;'a', 'r', 'b', 'c', 'd'&#125;&gt;&gt;&gt; a - b # letters in a but not in b&#123;'r', 'd', 'b'&#125;&gt;&gt;&gt; a | b # letters in a or b or both&#123;'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'&#125;&gt;&gt;&gt; a &amp; b # letters in both a and b&#123;'a', 'c'&#125;&gt;&gt;&gt; a ^ b # letters in a or b but not both&#123;'r', 'd', 'b', 'm', 'z', 'l'&#125; dict clear和copy方法，同list，shallow copy items，keys，values在3.6中返回的是view objects，提供了字典中item的动态绑定，支持len，iter和in的用法 classmethod fromkeys(seq, value)，seq为iterable，value不提供的话默认为None del d[key]和pop(key, default)都可以删除，但是key不存在都会报错，pop可以设置default返回值 popitem移除并返回随机的pair，可以很好用 setdefault(key, default), 如果key存在，相当于get，如果不存在，用default值进行set并返回default值，加强版set Iterable &amp; Iterator 以下摘自python3.6 glossary iterable: An object capable of returning its members one at a time. Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict, file objects, and objects of any classes you define with an __iter__() method or with a __getitem__() method that implements Sequence semantics. Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(), …). When an iterable object is passed as an argument to the built-in function iter(), it returns an iterator for the object. This iterator is good for one pass over the set of values. When using iterables, it is usually not necessary to call iter() or deal with iterator objects yourself. The for statement does that automatically for you, creating a temporary unnamed variable to hold the iterator for the duration of the loop. sequence: An iterable which supports efficient element access using integer indices via the __getitem__() special method and defines a __len__() method that returns the length of the sequence. Some built-in sequence types are list, str, tuple, and bytes. Note that dict also supports __getitem__() and __len__(), but is considered a mapping rather than a sequence because the lookups use arbitrary immutable keys rather than integers. iterator: An object representing a stream of data. Repeated calls to the iterator’s __next__() method (or passing it to the built-in function next()) return successive items in the stream. When no more data are available a StopIteration exception is raised instead. At this point, the iterator object is exhausted and any further calls to its __next__() method just raise StopIteration again. Iterators are required to have an __iter__() method that returns the iterator object itself so every iterator is also iterable and may be used in most places where other iterables are accepted. One notable exception is code which attempts multiple iteration passes. A container object (such as a list) produces a fresh new iterator each time you pass it to the iter() function or use it in a for loop. Attempting this with an iterator will just return the same exhausted iterator object used in the previous iteration pass, making it appear like an empty container. 上面的概念诠释的是python的builtin类型和collections包里面的Iterable&amp;Iterator类的区别和联系 Iterable有一个__iter__方法用来返回一个iterator，for关键字就是做了这部分工作 Iterator就是一个迭代器，一个迭代器有__iter和\next__方法，前者返回的迭代器就是它本身，后者每次返回一个元素 Interator是数据流，每次返回之前才会计算下一个元素，所以如果用list方法包装就会又变成一个已知长度的Iterable，这样for的时候就是一开始就把所有元素读到内存里 Iterator可以有很巧妙的用法，比如如果需要将一个列表从头开始每两个元素放到一个元组里面 12345678910111213&gt;&gt;&gt; a = ["foo", 2, "bar", 4, "far", 6]&gt;&gt;&gt; zip(a,a)&lt;zip object at 0x10be8bb48&gt;&gt;&gt;&gt; list(zip(a,a))[('foo', 'foo'), (2, 2), ('bar', 'bar'), (4, 4), ('far', 'far'), (6, 6)]&gt;&gt;&gt; [iter(a)]*2[&lt;list_iterator object at 0x10c014940&gt;, &lt;list_iterator object at 0x10c014940&gt;]&gt;&gt;&gt; ([iter(a)]*2)[&lt;list_iterator object at 0x10c014a58&gt;, &lt;list_iterator object at 0x10c014a58&gt;]&gt;&gt;&gt; list(zip(*([iter(a)]*2))...... )[('foo', 2), ('bar', 4), ('far', 6)] 可以注意到关键在于生成的两个迭代器是同一个，所以做到了把元素两两打包 Iterator/Iterable的相关内建函数 map(f, iterA, iterB, …)，filter(predicate, iter)，enumerate(iter, start=0)，zip(iterA, iterB, …)几个函数都会返回一个Iterator any(iter)和all(iter)两个函数接收Iterable的参数并且以或和且的方式返回一个布尔值 itertools模块]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sequence</tag>
      </tags>
  </entry>
</search>
